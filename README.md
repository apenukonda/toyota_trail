# Toyota Quality Month Event - App Setup

This is the complete and final setup script for your Supabase database. It will create all required tables, functions, and security policies.

**Instructions:**

1.  Navigate to the **SQL Editor** in your Supabase project dashboard.
2.  Click **"+ New query"**.
3.  Copy the entire script below, paste it into the editor, and click **"RUN"**.

This script is safe to re-run. It will automatically replace any previous versions of the tables or functions. **Warning:** Running this script will delete any existing user progress (scores, video progress, etc.) to ensure a clean and correct setup.

---

### Complete Database Setup Script

```sql
-- Step 1: Create Profiles Table & User Creation Trigger
-- This script is idempotent and safe to re-run.

-- Create a table for public user profiles if it doesn't exist.
create table if not exists public.profiles (
  id uuid not null primary key references auth.users(id) on delete cascade,
  user_id text,
  name text,
  department text,
  score integer not null default 0
);
comment on table public.profiles is 'Stores public user data, including their total score.';

-- Set up Row Level Security (RLS)
alter table public.profiles enable row level security;

-- Drop existing policies to ensure a clean slate
drop policy if exists "Public profiles are viewable by everyone." on public.profiles;
drop policy if exists "Users can insert their own profile." on public.profiles;
drop policy if exists "Users can update their own profile." on public.profiles;

create policy "Public profiles are viewable by everyone." on public.profiles
  for select using (true);

create policy "Users can insert their own profile." on public.profiles
  for insert with check (auth.uid() = id);

create policy "Users can update their own profile." on public.profiles
  for update using (auth.uid() = id);

-- This trigger automatically creates a profile entry when a new user signs up.
-- We use CREATE OR REPLACE FUNCTION and DROP TRIGGER IF EXISTS to make it re-runnable.
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, user_id, name, department)
  values (new.id, new.raw_user_meta_data->>'userId', new.raw_user_meta_data->>'name', new.raw_user_meta_data->>'department');
  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

comment on function public.handle_new_user is 'Trigger to create a profile when a new user signs up.';


-- Step 2: Create other tables.
-- WARNING: These will delete existing user progress.

-- Table for task progress
drop table if exists public.user_tasks cascade;
create table public.user_tasks (
    user_id uuid not null references auth.users(id) on delete cascade,
    task_id text not null,
    completed_steps integer not null default 0,
    score integer not null default 0,
    primary key (user_id, task_id)
);
alter table public.user_tasks enable row level security;
create policy "Users can manage their own task progress." on public.user_tasks for all using (auth.uid() = user_id);

-- Table for video progress
drop table if exists public.user_video_progress cascade;
create table public.user_video_progress (
    user_id uuid not null references auth.users(id) on delete cascade,
    video_id text not null,
    watched_seconds double precision not null default 0,
    is_complete boolean not null default false,
    primary key (user_id, video_id)
);
alter table public.user_video_progress enable row level security;
create policy "Users can manage own video progress." on public.user_video_progress for all using (auth.uid() = user_id);

-- Table for image submissions
drop table if exists public.image_submissions cascade;
create table public.image_submissions (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone not null default now(),
    user_id uuid not null references auth.users(id) on delete cascade,
    task_id text not null,
    image_url text not null
);
alter table public.image_submissions enable row level security;
create policy "Users can manage own image submissions." on public.image_submissions for all using (auth.uid() = user_id);


-- Step 3: Create Score Update Function
create or replace function public.handle_task_completion(
    task_id_in text,
    user_id_in uuid,
    completed_steps_in int,
    score_earned_in int
)
returns int
language plpgsql
security definer
as $$
declare
  new_total_score int;
begin
  -- Update the specific task's progress and score
  insert into public.user_tasks (user_id, task_id, completed_steps, score)
  values (user_id_in, task_id_in, completed_steps_in, score_earned_in)
  on conflict (user_id, task_id)
  do update set
    completed_steps = excluded.completed_steps,
    score = excluded.score;
  -- Compute total from user_tasks
  -- and total from per-module progress tables (if present). Use the larger
  -- of the two as authoritative so we don't accidentally reduce a user's
  -- total when module progress tables are the source of truth for some quizzes.
  declare
    total_user_tasks int := 0;
    total_module_progress int := 0;
    m1_sum int := 0;
    m2_sum int := 0;
    m3_sum int := 0;
  begin
    select coalesce(sum(score), 0) into total_user_tasks from public.user_tasks where user_id = user_id_in;

    -- If the module progress tables exist, sum their scores. If they don't exist
    -- the SELECT will yield NULL, so coalesce to 0.
    begin
      select coalesce(sum(score),0) into m1_sum from public.module_m1_progress where user_id = user_id_in;
    exception when undefined_table then
      m1_sum := 0;
    end;
    begin
      select coalesce(sum(score),0) into m2_sum from public.module_m2_progress where user_id = user_id_in;
    exception when undefined_table then
      m2_sum := 0;
    end;
    begin
      select coalesce(sum(score),0) into m3_sum from public.module_m3_progress where user_id = user_id_in;
    exception when undefined_table then
      m3_sum := 0;
    end;

    total_module_progress := coalesce(m1_sum,0) + coalesce(m2_sum,0) + coalesce(m3_sum,0);

    new_total_score := greatest(total_user_tasks, total_module_progress);

    update public.profiles
    set score = new_total_score
    where id = user_id_in
    returning score into new_total_score;

    return new_total_score;
  end;
end;
$$;
```

---

### Cloudinary Setup (for Image Submission Task)

The "Image Submission" task requires a free Cloudinary account to store the uploaded images.

1.  **Create a Cloudinary Account**:
    *   Sign up for a free account at [cloudinary.com](https://cloudinary.com/users/register/free).

2.  **Find Your Cloud Name**:
    *   On your Cloudinary Dashboard, you will see your **Cloud Name**. Copy this value.

3.  **Create an Unsigned Upload Preset**:
    *   Go to **Settings** (click the gear icon in the top right).
    *   Click on the **Upload** tab.
    *   Scroll down to the **Upload presets** section and click **"Add upload preset"**.
    *   Change the **Signing Mode** from `Signed` to `Unsigned`.
    *   You can give it a memorable name if you like, or use the one Cloudinary generates.
    *   Click **"Save"** at the top right.
    *   Copy the **Preset name** from the list.

4.  **Update the Application Code**:
    *   Open the file `components/ImageSubmissionTask.tsx`.
    *   Replace the placeholder values for `CLOUD_NAME` and `UPLOAD_PRESET` with the values you just copied from your Cloudinary account.
